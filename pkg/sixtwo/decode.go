package sixtwo

import (
	"github.com/pevans/erc/pkg/data"
)

type decoder struct {
	logSeg    *data.Segment
	physSeg   *data.Segment
	imageType int
	logOff    int
	physOff   int
}

//  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
var conv6bit = []data.Byte{
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 00
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0xFF, 0xFF, 0x08, 0x0C, 0xFF, 0x10, 0x14, 0x18, // 10
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x20, 0xFF, 0xFF, 0xFF, 0x24, 0x28, 0x2C, 0x30, 0x34, // 20
	0xFF, 0xFF, 0x38, 0x3C, 0x40, 0x44, 0x48, 0x4C, 0xFF, 0x50, 0x54, 0x58, 0x5C, 0x60, 0x64, 0x68, // 30
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x6C, 0xFF, 0x70, 0x74, 0x78, // 40
	0xFF, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0x80, 0x84, 0xFF, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, // 50
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xA4, 0xA8, 0xAC, 0xFF, 0xB0, 0xB4, 0xB8, 0xBC, 0xC0, 0xC4, 0xC8, // 60
	0xFF, 0xFF, 0xCC, 0xD0, 0xD4, 0xD8, 0xDC, 0xE0, 0xFF, 0xE4, 0xE8, 0xEC, 0xF0, 0xF4, 0xF8, 0xFC, // 70
}

func Decode(imageType int, src *data.Segment) (*data.Segment, error) {
	dec := &decoder{
		physSeg:   src,
		logSeg:    data.NewSegment(DosSize),
		imageType: imageType,
	}

	for track := 0; track < NumTracks; track++ {
		dec.writeTrack(track)
	}

	return dec.logSeg, nil
}

func (d *decoder) writeTrack(track int) {
	trackOff := (track * PhysTrackLen) + PhysTrackHeader

	for sect := 0; sect < NumSectors; sect++ {
		var (
			physSect = encPhysOrder[sect]
			logSect  = logicalSector(d.imageType, sect)
		)

		d.logOff = (track * LogTrackLen) + (logSect * LogSectorLen)
		d.physOff = trackOff + (physSect * PhysSectorLen)

		d.writeSector(track, sect)
	}
}

func (d *decoder) writeSector(track, sect int) {
	var (
		// Skip header and the data marker
		physOff = d.physOff + PhysSectorHeader + 3
		conv    = make([]data.Byte, 0x157)
		xor     = make([]data.Byte, 0x156)
	)

	for i := 0; i < 0x157; i++ {
		conv[i] = conv6bit[d.physSeg.Get(data.DByte(physOff+i))&0x7F]
	}

	for i, lval := 0, data.Byte(0); i < 0x156; i++ {
		xor[i] = lval ^ conv[i]
		lval = xor[i]
	}

	for i := data.Byte(0); i < 0x56; i++ {
		var (
			offac = i + 0xAC
			off56 = i + 0x56

			vac = (xor[int(offac)+0x56] & 0xFC) | ((xor[i] & 0x80) >> 7) | ((xor[i] & 0x40) >> 5)
			v56 = (xor[int(off56)+0x56] & 0xFC) | ((xor[i] & 0x20) >> 5) | ((xor[i] & 0x10) >> 3)
			v00 = (xor[i+0x56] & 0xFC) | ((xor[i] & 0x08) >> 3) | ((xor[i] & 0x04) >> 1)
		)

		if offac >= 0xAC {
			d.logSeg.Set(data.DByte(d.logOff+int(offac)), vac)
		}

		d.logSeg.Set(data.DByte(d.logOff+int(off56)), v56)
		d.logSeg.Set(data.DByte(d.logOff+int(i)), v00)
	}
}
