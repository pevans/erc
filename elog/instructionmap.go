package elog

import (
	"os"
	"sort"
	"sync"
)

// An InstructionMap is a container that holds a set of Instructions. Its only
// purpose is to debug the execution of some software being emulated.
type InstructionMap struct {
	m  map[uint64]*Instruction
	mu sync.Mutex
}

// NewInstructionMap returns a newly allocated instruction map.
func NewInstructionMap() *InstructionMap {
	return &InstructionMap{
		m:  make(map[uint64]*Instruction),
		mu: sync.Mutex{},
	}
}

// Add inserts a given line to the instruction map.
func (cm *InstructionMap) Add(line *Instruction) {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	key := instructionMapKey(line)
	existing, ok := cm.m[key]
	if !ok {
		cm.m[key] = line
		return
	}

	// If the line exists in the callmap, and it's speculative, we want to
	// replace it.
	if existing.Speculative && !line.Speculative {
		cm.m[key] = line
	}
}

// Exists returns true if the given line is already in the instruction map.
func (cm *InstructionMap) Exists(line *Instruction) bool {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	_, ok := cm.m[instructionMapKey(line)]
	return ok
}

// Instructions returns a string slice of every line in the instruction map.
// The provided slice will be sorted in ascending order -- by convention, this
// would be according to the addresses that instructions are executed.
func (cm *InstructionMap) Instructions() []string {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	lines := make([]string, 0, len(cm.m))

	for _, line := range cm.m {
		str := line.String()
		if line.Speculative {
			str += " (speculative)"
		}

		// Visually mark the end of a block with an additional newline
		if line.EndOfBlock {
			str += "\n"
		}

		lines = append(lines, str+"\n")
	}

	sort.Strings(lines)

	return lines
}

// A key in a callmap is a packed integer that encodes distinctive parts of
// the machine code that was executed. The structure looks like this:
//
// [ address | 16bits ][ operand | 16 bits ][ opcode | 8 bits ]
//
// This ends up taking 40 bits, so we produce a 64-bit key.
func instructionMapKey(line *Instruction) uint64 {
	key := uint64(line.Opcode)
	key |= uint64(line.Operand) << 8

	if line.Address != nil {
		key |= uint64(*line.Address) << 24
	}

	return key
}

// writePreamble returns a set of comments (at least, as would be considered
// comments in assembly notation for MOS chips) to explain how to read an
// instruction map.
func writePreamble(fp *os.File) error {
	preamble := `* This file is automatically generated by Erc. It contains instructions
* written in an MOS 6502 assembly notation. Here's an example line:
*
* 0801:4C 04 08 | MAIN     JMP $0804         this is a comment!
*
* "0801" is the PROGRAM COUNTER, or the address at which an instruction has
* been executed. You may find several instructions that have executed at the
* same program counter -- this can happen normally if the program is
* self-modifying.
*
* "4C 04 08" are bytes rendered in hexadecimal. Collectively, they respresent
* the OPCODE (the first byte) and the OPERAND (the second and third bytes). An
* opcode is a integer that corresponds to an instruction.
*
* An operand can be one or two bytes long. It can also be omitted for certain
* instructions. Operands are always encoded with the least significant byte
* first, followed by the most significant byte. For a 16-bit value like
* "0804", the machine code would have it as "04" followed by "08".
*
* "MAIN" is a label. Space is always made for labels in the output, but labels
* aren't representable in machine code, and we generally can't infer them.
* Since Apple software typically jumps to address 0801, we can assert this is
* the starting point of the software, and thus we label this line as MAIN.
* Feel free to add your own labels when reading an instruction log!
*
* "JMP" is the instruction that corresponds to the earlier opcode.
* Instructions that suggest the end of a routine (like JMP and RTS) are
* followed by a blank line to keep blocks of routines visually separate.
*
* "$0804" is a formatted version of the operand. The "$" tells the reader that
* this is shown as hexadecimal. Without it, many assemblers would assume
* numbers are in decimal. Operands may contain other special characters that
* indicates particular address modes (like "#" for immediate mode). Some
* operands are only a single byte and may be shorter than other operands. Some
* other operands may be represented by a word rather than a number; this can
* happen if the instruction references a named variable or subroutine.
*
* "this is a comment!" is, as you might guess, a comment. In some notations,
* anything that followed the operand was treated as a comment and ignored.
*
* Some lines may end in "(speculative)". If a branch could be taken, but
* wasn't, Erc attempts to "speculate" what might happen if it _was_
* taken. These instructions are never executed -- they are only viewed and
* printed in the log. You should note that speculation isn't perfect; you
* might see lines printed twice -- one speculatively, once really executed --
* because of how control flow has happened in the software.
*
* The purpose of such speculation is to allow you to see as much of the code in
* memory as is feasible. This isn't a perfect technique for such an end; we
* infer that code that may be branched is real code, but it's possible that
* the code author never intended for the branch to be taken, and we might
* speculate on what amounts to data, not code. Bear that in mind as you read
* the code. Bear also in mind that we don't speculate on code after a branch
* instruction that we _do_ take, for similar reasons: the author may have
* intended that the branch always be taken, and what follows it may be data.
*
* Program begins below:

`

	_, err := fp.WriteString(preamble)
	return err
}

// WriteToFile writes the formatted lines in the instruction map to the given
// filename. An error is returned if the file could not be created or written
// to.
func (cm *InstructionMap) WriteToFile(file string) error {
	lines := cm.Instructions()

	fp, err := os.Create(file)
	if err != nil {
		return err
	}

	defer fp.Close() //nolint:errcheck

	if err := writePreamble(fp); err != nil {
		return err
	}

	for _, line := range lines {
		if _, err := fp.WriteString(line); err != nil {
			return err
		}
	}

	return nil
}
