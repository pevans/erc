package asm

import (
	"os"
	"sort"
	"sync"
)

type CallMap struct {
	m  map[string]int
	mu sync.Mutex
}

func NewCallMap() *CallMap {
	return &CallMap{
		m:  make(map[string]int),
		mu: sync.Mutex{},
	}
}

func (cm *CallMap) Add(line string) {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	if _, ok := cm.m[line]; !ok {
		cm.m[line] = 1
		return
	}

	cm.m[line]++
}

func (cm *CallMap) Lines() []string {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	lines := make([]string, len(cm.m))

	for line := range cm.m {
		lines = append(lines, line+"\n")
	}

	sort.Strings(lines)

	return lines
}

func (cm *CallMap) WriteToFile(file string) error {
	lines := cm.Lines()

	fp, err := os.Create(file)
	if err != nil {
		return err
	}

	defer fp.Close() //nolint:errcheck

	if err := writePreamble(fp); err != nil {
		return err
	}

	for _, line := range lines {
		if _, err := fp.WriteString(line); err != nil {
			return err
		}
	}

	return nil
}

func writePreamble(fp *os.File) error {
	preamble := `* This file is automatically generated by Erc. It contains instructions
* written in an MOS 6502 assembly notation. Here's an example line:
*
* 0801:4C 04 08 | MAIN     JMP $0804         this is a comment!
*
* "0801" is the PROGRAM COUNTER, or the address at which an instruction has
* been executed. You may find several instructions that have executed at the
* same program counter -- this can happen normally if the program is
* self-modifying.
*
* "4C 04 08" are bytes rendered in hexadecimal. Collectively, they respresent
* the OPCODE (the first byte) and the OPERAND (the second and third bytes). An
* opcode is a integer that corresponds to an instruction.
*
* An operand can be one or two bytes long. It can also be omitted for certain
* instructions. Operands are always encoded with the least significant byte
* first, followed by the most significant byte. For a 16-bit value like
* "0804", the machine code would have it as "04" followed by "08".
*
* "MAIN" is a label. Space is always made for labels in the output, but labels
* aren't representable in machine code, and we generally can't infer them.
* Since Apple software typically jumps to address 0801, we can assert this is
* the starting point of the software, and thus we label this line as MAIN.
* Feel free to add your own labels when reading an instruction log!
*
* "JMP" is the instruction that corresponds to the earlier opcode.
* Instructions that suggest the end of a routine (like JMP and RTS) are
* followed by a blank line to keep blocks of routines visually separate.
*
* "$0804" is a formatted version of the operand. The "$" tells the reader that
* this is shown as hexadecimal. Without it, many assemblers would assume
* numbers are in decimal. Operands may contain other special characters that
* indicates particular address modes (like "#" for immediate mode). Some
* operands are only a single byte and may be shorter than other operands. Some
* other operands may be represented by a word rather than a number; this can
* happen if the instruction references a named variable or subroutine.
*
* "this is a comment!" is, as you might guess, a comment. In some notations,
* anything that followed the operand was treated as a comment and ignored.
*
* Program begins below:

`

	_, err := fp.WriteString(preamble)
	return err
}
